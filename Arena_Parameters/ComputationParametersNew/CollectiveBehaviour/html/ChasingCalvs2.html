
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>ChasingCalvs2</title><meta name="generator" content="MATLAB 9.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-04-21"><meta name="DC.source" content="ChasingCalvs2.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#4">%%%%%%%%%%%%%%% Begin Calculation %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</a></li><li><a href="#10">Calculate angle between line joining 1 to 2 and mouse 1 movement direction</a></li><li><a href="#11">Calculate angle between movement of mouse 1 and movement of mouse 2</a></li><li><a href="#12">Distance between the 2 trajectories</a></li><li><a href="#13">Looking for chasing when the distance is less than a given angle and the velocity and angle conditions are satisfied.</a></li><li><a href="#17">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</a></li><li><a href="#20">% vector of location between mouse</a></li><li><a href="#21">%calculate angle between vectors</a></li><li><a href="#26">% vector of movement second mouse</a></li><li><a href="#27">%calculate angle between vectors</a></li><li><a href="#30">%% -------------First function for data filtering------------------</a></li><li><a href="#32">-----------This function fill gaps between chasing events</a></li><li><a href="#34">-----------This function fill gaps between SMALL chasing events</a></li><li><a href="#35">-------------------------Function to find the exact beggining and end of the chasing----------------------</a></li><li><a href="#36">%% ----------------Second function for filtering</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> [chasing_all,being_chasing_all]=ChasingCalvs2(Params,Locomotion)
</pre><pre class="codeinput">  hbar=waitbar(0,<span class="string">'Calculating second version of Chasing'</span>)
  <span class="comment">%%Variable and parameters Definition</span>
  numOfMice=size(Locomotion.AssigRFID.miceList,1);
  chasing_all=cell(1,numOfMice);
  being_chasing_all=cell(1,numOfMice);

      TrajectoryX=Locomotion.AssigRFID.XcoordMM;
      TrajectoryY=Locomotion.AssigRFID.YcoordMM;
      isInArena=Locomotion.AssigRFID.Arena.InArena;
      Velocity=Locomotion.AssigRFID.VelocityMouse; <span class="comment">% this is the mod (speed) velocity</span>
      Vectorx=Locomotion.AssigRFID.VelocityMouseX; <span class="comment">% this is the x component of velocity</span>
      Vectory=Locomotion.AssigRFID.VelocityMouseY; <span class="comment">% this is the y component of velocity</span>
      DeltaX=diff(TrajectoryX);
      DeltaY=diff(TrajectoryY);
</pre><pre class="codeoutput">
hbar = 

  Figure (TMWWaitbar) with properties:

      Number: []
        Name: ''
       Color: [0.9400 0.9400 0.9400]
    Position: [585 376.8750 270 56.2500]
       Units: 'points'

  Use GET to show all properties

</pre><pre class="codeoutput error">Not enough input arguments.

Error in ChasingCalvs2 (line 4)
  numOfMice=size(Locomotion.AssigRFID.miceList,1);
</pre><h2 id="4">%%%%%%%%%%%%%%% Begin Calculation %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</h2><pre class="codeinput">  <span class="comment">%for mouse1=1:size(TrajectoryX,2) % Loop over every mouse</span>
     <span class="keyword">for</span> mouse1=1:size(Locomotion.AssigRFID.miceList,1)

      <span class="comment">% others = setdiff(1:size(TrajectoryX,2),mouse1);</span>
      others = setdiff(1:size(Locomotion.AssigRFID.miceList,1),mouse1);

       Trajectory1=[TrajectoryX(:,mouse1) TrajectoryY(:,mouse1)];
       Trajectory1(~isInArena(:,mouse1)|(TrajectoryX(:,mouse1)==1e6),:)=0; <span class="comment">% if it is outside the arena and the trayectory is non-defined</span>
      <span class="keyword">if</span> sum(sum(Trajectory1))==0 <span class="comment">%in the case is not in the arena</span>
           <span class="keyword">continue</span>;
        <span class="keyword">else</span>
        Velocity1=Velocity(:,mouse1);
         Vector1=[Vectorx(:,mouse1) Vectory(:,mouse1)];
       <span class="keyword">for</span> mouse2=others <span class="comment">% loop over the other mice</span>
</pre><pre class="codeinput">          <span class="comment">% Find both in the arena without hiding box</span>
</pre><p>Reset variables</p><pre class="codeinput">          clear <span class="string">angle1</span>;
          clear <span class="string">angle2</span>;
          clear <span class="string">ChasingVector</span>;
          clear <span class="string">BegChasingCorrected2</span>;
          clear <span class="string">EndChasingCorrected2</span>;
</pre><pre class="codeinput">             Trajectory2=[TrajectoryX(:,mouse2) TrajectoryY(:,mouse2)];
             Trajectory2(~isInArena(:,mouse2)|(TrajectoryX(:,mouse2)==1e6),:)=0; <span class="comment">% if it is outside the arena and the trayectory is non-defined</span>
                 <span class="keyword">if</span> sum(sum(Trajectory2))==0 <span class="comment">%in the case is not in the arena</span>
                          <span class="keyword">continue</span>;
                 <span class="keyword">else</span>
</pre><pre class="codeinput">                       Velocity2=Velocity(:,mouse2);
                       Vector2=[Vectorx(:,mouse2) Vectory(:,mouse2)];
                       timeLine=Locomotion.ExperimentTime;
                       IbothArena=isInArena(:,mouse1)&amp; isInArena(:,mouse2) ;
                       Inondefined=(TrajectoryX(:,mouse1)==1e6)|(TrajectoryX(:,mouse2)==1e6);
                       IForDistance=IbothArena &amp; ~Inondefined; <span class="comment">% assure both mouse in the arena and define</span>
</pre><h2 id="10">Calculate angle between line joining 1 to 2 and mouse 1 movement direction</h2><pre class="codeinput">                      angle1=cellfun(@FindAngle,num2cell(Trajectory1(1:size(DeltaX,1),1)),num2cell(Trajectory1(1:size(DeltaY,1),2)),<span class="keyword">...</span>
                                    num2cell(Trajectory2(1:size(DeltaX,1),1)),num2cell(Trajectory2(1:size(DeltaY,1),2)),<span class="keyword">...</span>
                                    num2cell(DeltaX(:,mouse1)),num2cell(DeltaY(:,mouse1)),<span class="string">'UniformOutput'</span>,false);
</pre><h2 id="11">Calculate angle between movement of mouse 1 and movement of mouse 2</h2><pre class="codeinput">                      angle2=cellfun(@FindAngleDirection,num2cell(DeltaX(:,mouse1)),num2cell(DeltaY(:,mouse1)),<span class="keyword">...</span>
                                    num2cell(DeltaX(:,mouse2)),num2cell(DeltaY(:,mouse2)),<span class="string">'UniformOutput'</span>,false);
</pre><h2 id="12">Distance between the 2 trajectories</h2><pre class="codeinput">                            DistFun=@(t1,t2) sqrt(sum((t1-t2).^2,2));
                            Distance=DistFun(Trajectory1,Trajectory2);
</pre><h2 id="13">Looking for chasing when the distance is less than a given angle and the velocity and angle conditions are satisfied.</h2><pre class="codeinput">                        ChasingVector=((cell2mat(angle1) &lt; Params.AngleMaximum1) &amp; (cell2mat(angle2) &lt; Params.AngleMaximum2) &amp; <span class="keyword">...</span>
                                       (IForDistance(1:size(DeltaY,1),1)==1) &amp; (Velocity(1:size(DeltaY,1),mouse1)&gt; Params.editpar3) &amp; (Velocity(1:size(DeltaY,1),mouse2)&gt;Params.editpar3) &amp;<span class="keyword">...</span>
                                       (Distance(1:size(DeltaY,1))&lt;Params.editpar2));<span class="comment">%this is a logical vector</span>

<span class="comment">%                       %% Caculate intervals</span>
                         [BegChasingCorrected2 EndChasingCorrected2]=getEventsIndexesGV(ChasingVector,length(ChasingVector));
<span class="comment">%</span>
<span class="comment">%                      %% -------------------------Select events-remove less than 3 events--------------</span>
                       v1=Velocity(1:size(DeltaY,1),mouse1);
                       v2=Velocity(1:size(DeltaY,1),mouse2);
                       [ChasingVector ChasingVectorWithSmallEvents]=RealEvents1(BegChasingCorrected2, EndChasingCorrected2,<span class="keyword">...</span>
                                                                    ChasingVector,DeltaX(:,mouse1),DeltaY(:,mouse1),<span class="keyword">...</span>
                                                                    DeltaX(:,mouse2),DeltaY(:,mouse2),Params.editpar1,v1,v2);
<span class="comment">%                      %% Calculate events for large events</span>
                         [BegChasingCorrected1 EndChasingCorrected1]=getEventsIndexesGV(ChasingVector,length(ChasingVector));
<span class="comment">%</span>
<span class="comment">%                      %% Calculate events for small events</span>
<span class="comment">%                         [BegChasingCorrected1S EndChasingCorrected1S]=getEventsIndexesGV(ChasingVectorWithSmallEvents,length(ChasingVectorWithSmallEvents));</span>
<span class="comment">%                      %% -------------------------------------------Unify events which are very near--------------------------------</span>
<span class="comment">%                           %------Large events</span>
                             ChasingVector=FillGap(BegChasingCorrected1, EndChasingCorrected1,ChasingVector,Trajectory1,Trajectory2,Params.editpar5,Params.editpar4);
<span class="comment">%                             [BegChasingCorrected3 EndChasingCorrected3]=getEventsIndexesGV(ChasingVector,length(ChasingVector));</span>
<span class="comment">%</span>
<span class="comment">%                          %----Small events-----------------</span>
<span class="comment">%                             ChasingVectorWithSmallEvents=FillGapSmall(BegChasingCorrected1S, EndChasingCorrected1S,ChasingVectorWithSmallEvents,Trajectory1,Trajectory2,Params.editpar7,Params.editpar6);</span>
<span class="comment">%                             [BegChasingCorrected3S EndChasingCorrected3S]=getEventsIndexesGV(ChasingVectorWithSmallEvents,length(ChasingVectorWithSmallEvents));</span>
<span class="comment">%                     %----------------------Once we know the chasing events find the beggining and end of each event</span>
<span class="comment">%                            ChasingVector=FindEnds(BegChasingCorrected3, EndChasingCorrected3,ChasingVector,Trajectory1,Trajectory2,Params.editpar5);</span>
<span class="comment">%                            ChasingVectorWithSmallEvents=FindEnds(BegChasingCorrected3S, EndChasingCorrected3S,...</span>
<span class="comment">%                                                                 ChasingVectorWithSmallEvents,Trajectory1,Trajectory2,Params.editpar5);</span>
<span class="comment">%</span>
<span class="comment">%                      %%---------------- Eliminate very small events</span>
<span class="comment">%</span>
<span class="comment">%                           [BegChasingCorrected4S EndChasingCorrected4S]=getEventsIndexesGV(ChasingVectorWithSmallEvents,length(ChasingVectorWithSmallEvents)); %THIS ALL THE CHASING</span>
<span class="comment">%                            ChasingVectorWithSmallEvents=RealEvents(BegChasingCorrected4S, EndChasingCorrected4S,...</span>
<span class="comment">%                                                                       ChasingVectorWithSmallEvents,DeltaX(:,mouse1),DeltaY(:,mouse1),DeltaX(:,mouse2),DeltaY(:,mouse2),...</span>
<span class="comment">%                                                                       Params.editpar1,Velocity(1:size(DeltaY,1),mouse1),Velocity(1:size(DeltaY,1),mouse2),Params.editpar3);</span>
<span class="comment">%                    %% -------------------- Join the two chasing events with small and large events</span>
<span class="comment">% %</span>
<span class="comment">%                        ChasingVector=or(ChasingVector,ChasingVectorWithSmallEvents);</span>
                       [BegChasingCorrected EndChasingCorrected]=getEventsIndexesGV(ChasingVector,length(ChasingVector)); <span class="comment">%THIS ALL THE CHASING</span>
<span class="comment">%                       [BegChasingCorrectedS EndChasingCorrectedS]=getEventsIndexesGV(ChasingVectorWithSmallEvents,length(ChasingVectorWithSmallEvents));%For Small events</span>
<span class="comment">%</span>
<span class="comment">%                      %make  a logical vector with small events</span>
<span class="comment">%                    %  SmallEvents=FoundSmallEvents(BegChasingCorrectedS,EndChasingCorrectedS,BegChasingCorrected, EndChasingCorrected);</span>

                   <span class="keyword">if</span> ~isempty(BegChasingCorrected)
                    <span class="comment">%chasing12=[BegChasingCorrected EndChasingCorrected mouse2*ones(length(BegChasingCorrected),1) SmallEvents];%Return real frames</span>
                    <span class="comment">%beingchasing21=[BegChasingCorrected EndChasingCorrected mouse1*ones(length(BegChasingCorrected),1) SmallEvents];</span>
                    chasing12=[BegChasingCorrected EndChasingCorrected mouse2*ones(length(BegChasingCorrected),1)];<span class="comment">%Return real frames</span>
                    beingchasing21=[BegChasingCorrected EndChasingCorrected mouse1*ones(length(BegChasingCorrected),1)];

                    chasing_all{mouse1}=[chasing_all{mouse1};chasing12];
                    being_chasing_all{mouse2}=[ being_chasing_all{mouse2};beingchasing21];
                   <span class="keyword">end</span>
  <span class="comment">%----------------------------------------------------------------------</span>
</pre><pre class="codeinput">             <span class="keyword">end</span>
</pre><pre class="codeinput">                 <span class="keyword">end</span>



      <span class="keyword">end</span>
        waitbar(j/length(length(numOfMice)));

  <span class="keyword">end</span>
       close(hbar);
</pre><pre class="codeinput">  <span class="keyword">end</span>
</pre><h2 id="17">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</h2><p>--------------------------Auxiliary function----------------------------</p><pre class="codeinput"><span class="keyword">function</span> [result]=FindAngle(x,y,x1,y1,dx,dy)
</pre><h2 id="20">% vector of location between mouse</h2><pre class="codeinput">vloc=[x1-x,y1-y];
<span class="comment">%vector movement</span>
vmov=[dx,dy];
</pre><h2 id="21">%calculate angle between vectors</h2><pre class="codeinput">Modvloc=norm(vloc);
Modvmov=norm(vmov);

<span class="keyword">if</span> vloc==0 <span class="comment">%the same coordinates as the angle is zero</span>
    result=0;
<span class="keyword">elseif</span> vmov==0
    result=1000;
<span class="keyword">else</span>
coseno=dot(vloc,vmov)/(Modvloc*Modvmov);
result=acos(coseno)*180/pi;
<span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">function</span> [result]=FindAngleDirection(dx,dy,dx1,dy1)
</pre><h2 id="26">% vector of movement second mouse</h2><pre class="codeinput">vmov2=[dx1,dy1];
<span class="comment">%vector movement</span>
vmov=[dx,dy];
</pre><h2 id="27">%calculate angle between vectors</h2><pre class="codeinput">Modvmov2=norm(vmov2);
Modvmov=norm(vmov);
<span class="keyword">if</span> Modvmov2~=0 &amp; Modvmov~=0
coseno=dot(vmov,vmov2)/(Modvmov2*Modvmov);
result=acos(coseno)*180/pi;
<span class="keyword">else</span>
    result=1000;
<span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">function</span> [EventsBeg EventsEnd]=getEventsIndexesGV(IndLogical,n)

EventsBeg=find(diff(IndLogical)==1)+1;
EventsEnd=find(diff(IndLogical)==-1);

<span class="keyword">if</span> isempty(EventsBeg)||isempty(EventsEnd)
    <span class="keyword">if</span>(isempty(EventsBeg)&amp;&amp;~isempty(EventsEnd))
        EventsBeg=[1;EventsBeg];
    <span class="keyword">elseif</span>(isempty(EventsEnd)&amp;&amp;~isempty(EventsBeg))
        EventsEnd=[EventsEnd;n];
    <span class="keyword">else</span>
        <span class="keyword">if</span> sum(IndLogical)==n
            EventsBeg=1;
            EventsEnd=n;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">else</span>
    <span class="keyword">if</span>(EventsBeg(1)&gt;EventsEnd(1))
        EventsBeg=[1;EventsBeg];
    <span class="keyword">end</span>

    <span class="keyword">if</span>(EventsBeg(end)&gt;EventsEnd(end))
        EventsEnd=[EventsEnd;n];
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">end</span>
</pre><h2 id="30">%% -------------First function for data filtering------------------</h2><pre class="codeinput"><span class="keyword">function</span> [ChasingVector ChasingVectorWithSmallEvents] =RealEvents1(BegChasing, EndChasing,ChasingVector,Dx1,Dy1,Dx2,Dy2,MinimumPath,v1,v2)

ChasingVectorWithSmallEvents=[];

ChasingVectorWithSmallEvents=zeros(length(ChasingVector),1);


<span class="keyword">if</span> ~isempty(BegChasing)

   <span class="keyword">for</span> i=1:length(BegChasing)


     <span class="keyword">if</span>  (EndChasing(i)-BegChasing(i))&lt;3

        ChasingVector(BegChasing(i):EndChasing(i))=0; <span class="comment">%ELIMINATE CHASING EVENTS IF THERE AS LESS THAN 3 EVENTS</span>


     <span class="keyword">else</span>

    DeltaX1=Dx1(BegChasing(i):EndChasing(i));
    DeltaY1=Dy1(BegChasing(i):EndChasing(i));

    DeltaX2=Dx2(BegChasing(i):EndChasing(i));
    DeltaY2=Dy2(BegChasing(i):EndChasing(i));

    DistFun1=sum(sqrt((DeltaX1).^2+(DeltaY1).^2));<span class="comment">%all the distance done during this chasing</span>
    DistFun2=sum(sqrt((DeltaX2).^2+(DeltaY2).^2));

    <span class="keyword">if</span> DistFun1&lt; MinimumPath | DistFun2&lt; MinimumPath

      ChasingVector(BegChasing(i):EndChasing(i))=0; <span class="comment">%ELIMINATE CHASING EVENTS IF THE TRAYECTORY ARE VERY SMALL</span>
      ChasingVectorWithSmallEvents(BegChasing(i):EndChasing(i))=1; <span class="comment">%CONSIDER ONLY SMALL EVENTS</span>

    <span class="keyword">end</span>
    <span class="comment">% If velocity inside the event is very high don't consider it</span>
    <span class="keyword">if</span> any(v1(BegChasing(i):EndChasing(i))&gt;150) | any(v2(BegChasing(i):EndChasing(i))&gt;150)
        ChasingVector(BegChasing(i):EndChasing(i))=0; <span class="comment">%ELIMINATE CHASING EVENTS</span>
    <span class="keyword">end</span>


   <span class="keyword">end</span>
   <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">end</span>
</pre><h2 id="32">-----------This function fill gaps between chasing events</h2><pre class="codeinput"><span class="keyword">function</span> ChasingVector=FillGap(BegChasing, EndChasing,ChasingVector,Trajectory1,Trajectory2,GapPathEnd,GapFrames)

<span class="keyword">if</span> ~isempty(BegChasing)&amp; length(BegChasing)&gt;1
  <span class="keyword">for</span> i=1:length(BegChasing)-1
    <span class="keyword">if</span> (BegChasing(i+1)-EndChasing(i))&lt;GapFrames <span class="comment">%if the difference in frames between gaps in the chasing is less than a given value</span>
     <span class="comment">%check if the trajectories are near</span>

   <span class="comment">%-----------Difference between the 2 trajectories------------------------</span>
          <span class="comment">%   DistFun=@(t1,t2) sqrt(sum((t1-t2).^2,2));</span>
<span class="comment">%              Trajectory1(EndChasing(i)+1:BegChasing(i+1)-1,:)</span>
<span class="comment">%              Trajectory2(EndChasing(i)+1:BegChasing(i+1)-1,:)</span>
          <span class="comment">%   Distance=DistFun(Trajectory1(EndChasing(i)+1:BegChasing(i+1)-1,:),Trajectory2(EndChasing(i)+1:BegChasing(i+1)-1,:));</span>
<span class="comment">%----------------------------------find near trajectories-------------------</span>

          <span class="comment">%  Index_proximity=(Distance &gt; GapPathEnd); %if this condition is empty the trajectory are near then the chasing is filled with one</span>


            <span class="comment">%  if isempty(find(Index_proximity)==1)</span>
                ChasingVector(EndChasing(i)+1:BegChasing(i+1)-1)=1;

           <span class="comment">%   end</span>


<span class="comment">%--------------------------------------------------------------------------------------------</span>





   <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">end</span>
</pre><h2 id="34">-----------This function fill gaps between SMALL chasing events</h2><pre class="codeinput"><span class="keyword">function</span> ChasingVector=FillGapSmall(BegChasing, EndChasing,ChasingVector,Trajectory1,Trajectory2,GapPathEndS,GapFramesS)

<span class="keyword">if</span> ~isempty(BegChasing)&amp; length(BegChasing)&gt;1
 <span class="keyword">for</span> i=1:length(BegChasing)-1
    <span class="keyword">if</span> (BegChasing(i+1)-EndChasing(i))&lt;GapFramesS <span class="comment">%if the difference in frames between gaps in the chasing is less than a given value REDUCE TEN TIMES THE GAP</span>
     <span class="comment">%check if the trajectories are near</span>

   <span class="comment">%-----------Difference between the 2 trajectories------------------------</span>
             DistFun=@(t1,t2) sqrt(sum((t1-t2).^2,2));
<span class="comment">%              Trajectory1(EndChasing(i)+1:BegChasing(i+1)-1,:)</span>
<span class="comment">%              Trajectory2(EndChasing(i)+1:BegChasing(i+1)-1,:)</span>
             Distance=DistFun(Trajectory1(EndChasing(i)+1:BegChasing(i+1)-1,:),Trajectory2(EndChasing(i)+1:BegChasing(i+1)-1,:));
<span class="comment">%----------------------------------find near trajectories-------------------</span>

            Index_proximity=(Distance &gt; GapPathEndS); <span class="comment">%if this condition is empty the trajectory are near then the chasing is filled with one</span>


              <span class="keyword">if</span> isempty(find(Index_proximity)==1)
                ChasingVector(EndChasing(i)+1:BegChasing(i+1)-1)=1;

              <span class="keyword">end</span>


<span class="comment">%--------------------------------------------------------------------------------------------</span>





   <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">end</span>
</pre><h2 id="35">-------------------------Function to find the exact beggining and end of the chasing----------------------</h2><pre class="codeinput"><span class="keyword">function</span> ChasingVector=FindEnds(BegChasing, EndChasing,ChasingVector,Trajectory1,Trajectory2,GapPath)

   <span class="comment">%-----------Distance between the 2 trajectories------------------------</span>
             DistFun=@(t1,t2) sqrt(sum((t1-t2).^2,2));
<span class="comment">%</span>
            DistanceT=DistFun(Trajectory1(1:end,:),Trajectory2(1:end,:));
  A=length(ChasingVector);
<span class="keyword">if</span> ~isempty(BegChasing)

   <span class="keyword">for</span> i=1:length(BegChasing)

<span class="comment">%----------------Correct the beggining of the chasing---------------</span>
     <span class="keyword">if</span> (BegChasing(i)&gt;1)
        IndBeginChasing=find(DistanceT(1:BegChasing(i)-1)&gt;GapPath,1,<span class="string">'last'</span>);<span class="comment">%the idea is to found the moment the trajectory are near</span>

         <span class="keyword">if</span> ~isempty( IndBeginChasing)
            ChasingVector(IndBeginChasing:BegChasing(i)-1)=1; <span class="comment">%correct chasing vector</span>
         <span class="keyword">end</span>

     <span class="keyword">end</span>

<span class="comment">%---------------------------------------</span>

<span class="comment">%----------------Correct the end  of the chasing---------------</span>
     <span class="keyword">if</span> (EndChasing(i)&lt;length(ChasingVector))
        IndEndChasing=find(DistanceT(EndChasing(i)+1:end)&gt;GapPath,1,<span class="string">'first'</span>);<span class="comment">%the idea is to found the moment the trajectory are separated at the end of the chasing</span>

         <span class="keyword">if</span> ~isempty(IndEndChasing)
             <span class="keyword">if</span> (EndChasing(i)+1+IndEndChasing-1)&lt;=A <span class="comment">%to avoid go out of the chasing size</span>
            ChasingVector(EndChasing(i)+1:EndChasing(i)+1+IndEndChasing-1)=1; <span class="comment">%correct chasing vector</span>
             <span class="keyword">end</span>
          <span class="keyword">end</span>

     <span class="keyword">end</span>
   <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% B=length(ChasingVector)</span>

<span class="keyword">end</span>


<span class="comment">%---------------------------------------</span>
</pre><h2 id="36">%% ----------------Second function for filtering</h2><pre class="codeinput"><span class="keyword">function</span> ChasingVector=RealEvents(BegChasing, EndChasing,ChasingVector,Dx1,Dy1,Dx2,Dy2,MinimumPath,V1,V2,VelocityThresh)
clear <span class="string">DeltaX1</span>;
clear <span class="string">DeltaX2</span>;
clear <span class="string">DeltaY1</span>;
clear <span class="string">DeltaY2</span>;

<span class="comment">% length(ChasingVector)</span>

<span class="keyword">if</span> ~isempty(BegChasing)

   <span class="keyword">for</span> i=1:length(BegChasing)


     <span class="keyword">if</span>  (EndChasing(i)-BegChasing(i))&lt;10 <span class="comment">%for small events less than 10 no consider</span>

        ChasingVector(BegChasing(i):EndChasing(i))=0; <span class="comment">%ELIMINATE CHASING EVENTS IF THERE AS LESS THAN 3 EVENTS</span>


     <span class="keyword">else</span>


    DeltaX1=Dx1(BegChasing(i):EndChasing(i));
    DeltaY1=Dy1(BegChasing(i):EndChasing(i));

    DeltaX2=Dx2(BegChasing(i):EndChasing(i));
    DeltaY2=Dy2(BegChasing(i):EndChasing(i));

   MedV1= median(V1(BegChasing(i):EndChasing(i)));
   MedV2= median(V2(BegChasing(i):EndChasing(i)));

    DistFun1=sum(sqrt((DeltaX1).^2+(DeltaY1).^2));<span class="comment">%all the distance done during this chasing</span>
    DistFun2=sum(sqrt((DeltaX2).^2+(DeltaY2).^2));

    <span class="keyword">if</span> DistFun1&lt; MinimumPath | DistFun2&lt; MinimumPath

      ChasingVector(BegChasing(i):EndChasing(i))=0; <span class="comment">%ELIMINATE CHASING EVENTS IF THE TRAYECTORY ARE VERY SMALL</span>
    <span class="keyword">elseif</span>   MedV1 &lt; VelocityThresh | MedV2&lt; VelocityThresh                   <span class="comment">%check velocity median bigger than the thrheshold during this period if not it was not moving</span>
         ChasingVector(BegChasing(i):EndChasing(i))=0; <span class="comment">%ELIMINATE CHASING EVENTS IF THE mouse is not moving enough for cases it is in the eating place all the time.</span>
    <span class="keyword">end</span>

   <span class="keyword">end</span>



<span class="keyword">end</span>

<span class="keyword">end</span>

<span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018b</a><br></p></div><!--
##### SOURCE BEGIN #####
function [chasing_all,being_chasing_all]=ChasingCalvs2(Params,Locomotion)
  hbar=waitbar(0,'Calculating second version of Chasing')
  %%Variable and parameters Definition
  numOfMice=size(Locomotion.AssigRFID.miceList,1);
  chasing_all=cell(1,numOfMice);
  being_chasing_all=cell(1,numOfMice); 
  
      TrajectoryX=Locomotion.AssigRFID.XcoordMM;
      TrajectoryY=Locomotion.AssigRFID.YcoordMM;
      isInArena=Locomotion.AssigRFID.Arena.InArena;
      Velocity=Locomotion.AssigRFID.VelocityMouse; % this is the mod (speed) velocity
      Vectorx=Locomotion.AssigRFID.VelocityMouseX; % this is the x component of velocity
      Vectory=Locomotion.AssigRFID.VelocityMouseY; % this is the y component of velocity
      DeltaX=diff(TrajectoryX);
      DeltaY=diff(TrajectoryY);
  %% 
   %% %%%%%%%%%%%%%%% Begin Calculation %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %for mouse1=1:size(TrajectoryX,2) % Loop over every mouse
     for mouse1=1:size(Locomotion.AssigRFID.miceList,1)
         
      % others = setdiff(1:size(TrajectoryX,2),mouse1);
      others = setdiff(1:size(Locomotion.AssigRFID.miceList,1),mouse1);
      
       Trajectory1=[TrajectoryX(:,mouse1) TrajectoryY(:,mouse1)];
       Trajectory1(~isInArena(:,mouse1)|(TrajectoryX(:,mouse1)==1e6),:)=0; % if it is outside the arena and the trayectory is non-defined
      if sum(sum(Trajectory1))==0 %in the case is not in the arena
           continue;
        else     
        Velocity1=Velocity(:,mouse1); 
         Vector1=[Vectorx(:,mouse1) Vectory(:,mouse1)];
       for mouse2=others % loop over the other mice
          % Find both in the arena without hiding box
          %% 
          % Reset variables
          clear angle1;
          clear angle2;
          clear ChasingVector;
          clear BegChasingCorrected2;
          clear EndChasingCorrected2;
          
          %% 
          
             Trajectory2=[TrajectoryX(:,mouse2) TrajectoryY(:,mouse2)];
             Trajectory2(~isInArena(:,mouse2)|(TrajectoryX(:,mouse2)==1e6),:)=0; % if it is outside the arena and the trayectory is non-defined
                 if sum(sum(Trajectory2))==0 %in the case is not in the arena
                          continue;
                 else   
                       Velocity2=Velocity(:,mouse2); 
                       Vector2=[Vectorx(:,mouse2) Vectory(:,mouse2)];
                       timeLine=Locomotion.ExperimentTime;
                       IbothArena=isInArena(:,mouse1)& isInArena(:,mouse2) ;
                       Inondefined=(TrajectoryX(:,mouse1)==1e6)|(TrajectoryX(:,mouse2)==1e6); 
                       IForDistance=IbothArena & ~Inondefined; % assure both mouse in the arena and define
                       %% 
                       %% Calculate angle between line joining 1 to 2 and mouse 1 movement direction
             
                      angle1=cellfun(@FindAngle,num2cell(Trajectory1(1:size(DeltaX,1),1)),num2cell(Trajectory1(1:size(DeltaY,1),2)),...
                                    num2cell(Trajectory2(1:size(DeltaX,1),1)),num2cell(Trajectory2(1:size(DeltaY,1),2)),...
                                    num2cell(DeltaX(:,mouse1)),num2cell(DeltaY(:,mouse1)),'UniformOutput',false);   
                        
                         %% Calculate angle between movement of mouse 1 and movement of mouse 2
             
                      angle2=cellfun(@FindAngleDirection,num2cell(DeltaX(:,mouse1)),num2cell(DeltaY(:,mouse1)),...
                                    num2cell(DeltaX(:,mouse2)),num2cell(DeltaY(:,mouse2)),'UniformOutput',false);
                         
                          %% Distance between the 2 trajectories
                            DistFun=@(t1,t2) sqrt(sum((t1-t2).^2,2));
                            Distance=DistFun(Trajectory1,Trajectory2);
                      %% Looking for chasing when the distance is less than a given angle and the velocity and angle conditions are satisfied.

                        ChasingVector=((cell2mat(angle1) < Params.AngleMaximum1) & (cell2mat(angle2) < Params.AngleMaximum2) & ...
                                       (IForDistance(1:size(DeltaY,1),1)==1) & (Velocity(1:size(DeltaY,1),mouse1)> Params.editpar3) & (Velocity(1:size(DeltaY,1),mouse2)>Params.editpar3) &...
                                       (Distance(1:size(DeltaY,1))<Params.editpar2));%this is a logical vector   
                        
%                       %% Caculate intervals
                         [BegChasingCorrected2 EndChasingCorrected2]=getEventsIndexesGV(ChasingVector,length(ChasingVector));
%                      
%                      %% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-Select events-remove less than 3 eventsREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
                       v1=Velocity(1:size(DeltaY,1),mouse1);
                       v2=Velocity(1:size(DeltaY,1),mouse2);
                       [ChasingVector ChasingVectorWithSmallEvents]=RealEvents1(BegChasingCorrected2, EndChasingCorrected2,...
                                                                    ChasingVector,DeltaX(:,mouse1),DeltaY(:,mouse1),...
                                                                    DeltaX(:,mouse2),DeltaY(:,mouse2),Params.editpar1,v1,v2);
%                      %% Calculate events for large events
                         [BegChasingCorrected1 EndChasingCorrected1]=getEventsIndexesGV(ChasingVector,length(ChasingVector)); 
%                      
%                      %% Calculate events for small events
%                         [BegChasingCorrected1S EndChasingCorrected1S]=getEventsIndexesGV(ChasingVectorWithSmallEvents,length(ChasingVectorWithSmallEvents)); 
%                      %% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-Unify events which are very nearREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH   
%                           %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHLarge events
                             ChasingVector=FillGap(BegChasingCorrected1, EndChasingCorrected1,ChasingVector,Trajectory1,Trajectory2,Params.editpar5,Params.editpar4);
%                             [BegChasingCorrected3 EndChasingCorrected3]=getEventsIndexesGV(ChasingVector,length(ChasingVector)); 
%              
%                          %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHSmall eventsREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%                             ChasingVectorWithSmallEvents=FillGapSmall(BegChasingCorrected1S, EndChasingCorrected1S,ChasingVectorWithSmallEvents,Trajectory1,Trajectory2,Params.editpar7,Params.editpar6);
%                             [BegChasingCorrected3S EndChasingCorrected3S]=getEventsIndexesGV(ChasingVectorWithSmallEvents,length(ChasingVectorWithSmallEvents));   
%                     %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHOnce we know the chasing events find the beggining and end of each event
%                            ChasingVector=FindEnds(BegChasingCorrected3, EndChasingCorrected3,ChasingVector,Trajectory1,Trajectory2,Params.editpar5);
%                            ChasingVectorWithSmallEvents=FindEnds(BegChasingCorrected3S, EndChasingCorrected3S,...
%                                                                 ChasingVectorWithSmallEvents,Trajectory1,Trajectory2,Params.editpar5);  
%                      
%                      %%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH Eliminate very small events
%            
%                           [BegChasingCorrected4S EndChasingCorrected4S]=getEventsIndexesGV(ChasingVectorWithSmallEvents,length(ChasingVectorWithSmallEvents)); %THIS ALL THE CHASING
%                            ChasingVectorWithSmallEvents=RealEvents(BegChasingCorrected4S, EndChasingCorrected4S,...
%                                                                       ChasingVectorWithSmallEvents,DeltaX(:,mouse1),DeltaY(:,mouse1),DeltaX(:,mouse2),DeltaY(:,mouse2),...
%                                                                       Params.editpar1,Velocity(1:size(DeltaY,1),mouse1),Velocity(1:size(DeltaY,1),mouse2),Params.editpar3);
%                    %% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH Join the two chasing events with small and large events
% %             
%                        ChasingVector=or(ChasingVector,ChasingVectorWithSmallEvents);  
                       [BegChasingCorrected EndChasingCorrected]=getEventsIndexesGV(ChasingVector,length(ChasingVector)); %THIS ALL THE CHASING
%                       [BegChasingCorrectedS EndChasingCorrectedS]=getEventsIndexesGV(ChasingVectorWithSmallEvents,length(ChasingVectorWithSmallEvents));%For Small events
%              
%                      %make  a logical vector with small events
%                    %  SmallEvents=FoundSmallEvents(BegChasingCorrectedS,EndChasingCorrectedS,BegChasingCorrected, EndChasingCorrected);
             
                   if ~isempty(BegChasingCorrected)
                    %chasing12=[BegChasingCorrected EndChasingCorrected mouse2*ones(length(BegChasingCorrected),1) SmallEvents];%Return real frames
                    %beingchasing21=[BegChasingCorrected EndChasingCorrected mouse1*ones(length(BegChasingCorrected),1) SmallEvents]; 
                    chasing12=[BegChasingCorrected EndChasingCorrected mouse2*ones(length(BegChasingCorrected),1)];%Return real frames
                    beingchasing21=[BegChasingCorrected EndChasingCorrected mouse1*ones(length(BegChasingCorrected),1)]; 
                  
                    chasing_all{mouse1}=[chasing_all{mouse1};chasing12];
                    being_chasing_all{mouse2}=[ being_chasing_all{mouse2};beingchasing21];
                   end 
  %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH           
             end
                       
                      
                 end        
                     
      
      
      end
        waitbar(j/length(length(numOfMice)));  
  
  end
       close(hbar);
  end 

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHAuxiliary functionREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH

%% 
function [result]=FindAngle(x,y,x1,y1,dx,dy)

%% % vector of location between mouse 
vloc=[x1-x,y1-y];
%vector movement
vmov=[dx,dy];
%% %calculate angle between vectors
Modvloc=norm(vloc);
Modvmov=norm(vmov);

if vloc==0 %the same coordinates as the angle is zero
    result=0;
elseif vmov==0
    result=1000;
else    
coseno=dot(vloc,vmov)/(Modvloc*Modvmov);
result=acos(coseno)*180/pi;
end
end
%% 

%% 
function [result]=FindAngleDirection(dx,dy,dx1,dy1)

%% % vector of movement second mouse 
vmov2=[dx1,dy1];
%vector movement
vmov=[dx,dy];
%% %calculate angle between vectors
Modvmov2=norm(vmov2);
Modvmov=norm(vmov);
if Modvmov2~=0 & Modvmov~=0
coseno=dot(vmov,vmov2)/(Modvmov2*Modvmov);
result=acos(coseno)*180/pi;
else
    result=1000;
end
end
%% 
function [EventsBeg EventsEnd]=getEventsIndexesGV(IndLogical,n)

EventsBeg=find(diff(IndLogical)==1)+1;
EventsEnd=find(diff(IndLogical)==-1);

if isempty(EventsBeg)||isempty(EventsEnd)
    if(isempty(EventsBeg)&&~isempty(EventsEnd))
        EventsBeg=[1;EventsBeg];
    elseif(isempty(EventsEnd)&&~isempty(EventsBeg))
        EventsEnd=[EventsEnd;n];
    else
        if sum(IndLogical)==n
            EventsBeg=1;
            EventsEnd=n;
        end
    end
else
    if(EventsBeg(1)>EventsEnd(1))
        EventsBeg=[1;EventsBeg];
    end
    
    if(EventsBeg(end)>EventsEnd(end))
        EventsEnd=[EventsEnd;n];
    end
end

end

%% %% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-First function for data filteringREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function [ChasingVector ChasingVectorWithSmallEvents] =RealEvents1(BegChasing, EndChasing,ChasingVector,Dx1,Dy1,Dx2,Dy2,MinimumPath,v1,v2)

ChasingVectorWithSmallEvents=[];

ChasingVectorWithSmallEvents=zeros(length(ChasingVector),1);


if ~isempty(BegChasing)
    
   for i=1:length(BegChasing)
       
       
     if  (EndChasing(i)-BegChasing(i))<3 
       
        ChasingVector(BegChasing(i):EndChasing(i))=0; %ELIMINATE CHASING EVENTS IF THERE AS LESS THAN 3 EVENTS
        
      
     else
       
    DeltaX1=Dx1(BegChasing(i):EndChasing(i));
    DeltaY1=Dy1(BegChasing(i):EndChasing(i));
    
    DeltaX2=Dx2(BegChasing(i):EndChasing(i));
    DeltaY2=Dy2(BegChasing(i):EndChasing(i));
    
    DistFun1=sum(sqrt((DeltaX1).^2+(DeltaY1).^2));%all the distance done during this chasing   
    DistFun2=sum(sqrt((DeltaX2).^2+(DeltaY2).^2));   
     
    if DistFun1< MinimumPath | DistFun2< MinimumPath
        
      ChasingVector(BegChasing(i):EndChasing(i))=0; %ELIMINATE CHASING EVENTS IF THE TRAYECTORY ARE VERY SMALL  
      ChasingVectorWithSmallEvents(BegChasing(i):EndChasing(i))=1; %CONSIDER ONLY SMALL EVENTS  
        
    end
    % If velocity inside the event is very high don't consider it
    if any(v1(BegChasing(i):EndChasing(i))>150) | any(v2(BegChasing(i):EndChasing(i))>150)
        ChasingVector(BegChasing(i):EndChasing(i))=0; %ELIMINATE CHASING EVENTS
    end
    
    
   end
   end
end
end
   
   %% 
  %% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-This function fill gaps between chasing events
function ChasingVector=FillGap(BegChasing, EndChasing,ChasingVector,Trajectory1,Trajectory2,GapPathEnd,GapFrames)

if ~isempty(BegChasing)& length(BegChasing)>1
  for i=1:length(BegChasing)-1
    if (BegChasing(i+1)-EndChasing(i))<GapFrames %if the difference in frames between gaps in the chasing is less than a given value
     %check if the trajectories are near
     
   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-Difference between the 2 trajectoriesREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
          %   DistFun=@(t1,t2) sqrt(sum((t1-t2).^2,2));
%              Trajectory1(EndChasing(i)+1:BegChasing(i+1)-1,:)
%              Trajectory2(EndChasing(i)+1:BegChasing(i+1)-1,:)
          %   Distance=DistFun(Trajectory1(EndChasing(i)+1:BegChasing(i+1)-1,:),Trajectory2(EndChasing(i)+1:BegChasing(i+1)-1,:));
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfind near trajectoriesREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
           
          %  Index_proximity=(Distance > GapPathEnd); %if this condition is empty the trajectory are near then the chasing is filled with one
           
           
            %  if isempty(find(Index_proximity)==1)
                ChasingVector(EndChasing(i)+1:BegChasing(i+1)-1)=1; 
    
           %   end


%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH  
     




   end
end
end
end  
%%
%% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-This function fill gaps between SMALL chasing events
function ChasingVector=FillGapSmall(BegChasing, EndChasing,ChasingVector,Trajectory1,Trajectory2,GapPathEndS,GapFramesS)

if ~isempty(BegChasing)& length(BegChasing)>1
 for i=1:length(BegChasing)-1
    if (BegChasing(i+1)-EndChasing(i))<GapFramesS %if the difference in frames between gaps in the chasing is less than a given value REDUCE TEN TIMES THE GAP
     %check if the trajectories are near
     
   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-Difference between the 2 trajectoriesREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
             DistFun=@(t1,t2) sqrt(sum((t1-t2).^2,2));
%              Trajectory1(EndChasing(i)+1:BegChasing(i+1)-1,:)
%              Trajectory2(EndChasing(i)+1:BegChasing(i+1)-1,:)
             Distance=DistFun(Trajectory1(EndChasing(i)+1:BegChasing(i+1)-1,:),Trajectory2(EndChasing(i)+1:BegChasing(i+1)-1,:));
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfind near trajectoriesREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
           
            Index_proximity=(Distance > GapPathEndS); %if this condition is empty the trajectory are near then the chasing is filled with one
           
           
              if isempty(find(Index_proximity)==1)
                ChasingVector(EndChasing(i)+1:BegChasing(i+1)-1)=1; 
    
              end


%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH  
     




   end
end
end
end
%% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-Function to find the exact beggining and end of the chasingREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH

function ChasingVector=FindEnds(BegChasing, EndChasing,ChasingVector,Trajectory1,Trajectory2,GapPath)

   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-Distance between the 2 trajectoriesREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
             DistFun=@(t1,t2) sqrt(sum((t1-t2).^2,2));
%           
            DistanceT=DistFun(Trajectory1(1:end,:),Trajectory2(1:end,:));
  A=length(ChasingVector);           
if ~isempty(BegChasing)
    
   for i=1:length(BegChasing)

%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHCorrect the beggining of the chasingREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
     if (BegChasing(i)>1)
        IndBeginChasing=find(DistanceT(1:BegChasing(i)-1)>GapPath,1,'last');%the idea is to found the moment the trajectory are near
        
         if ~isempty( IndBeginChasing)
            ChasingVector(IndBeginChasing:BegChasing(i)-1)=1; %correct chasing vector
         end
         
     end

%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-

%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHCorrect the end  of the chasingREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
     if (EndChasing(i)<length(ChasingVector))
        IndEndChasing=find(DistanceT(EndChasing(i)+1:end)>GapPath,1,'first');%the idea is to found the moment the trajectory are separated at the end of the chasing
      
         if ~isempty(IndEndChasing)
             if (EndChasing(i)+1+IndEndChasing-1)<=A %to avoid go out of the chasing size
            ChasingVector(EndChasing(i)+1:EndChasing(i)+1+IndEndChasing-1)=1; %correct chasing vector
             end
          end
         
     end
   end
end

% B=length(ChasingVector)

end

 
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%% %% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHSecond function for filtering
function ChasingVector=RealEvents(BegChasing, EndChasing,ChasingVector,Dx1,Dy1,Dx2,Dy2,MinimumPath,V1,V2,VelocityThresh)
clear DeltaX1;
clear DeltaX2;
clear DeltaY1;
clear DeltaY2;

% length(ChasingVector)

if ~isempty(BegChasing)
    
   for i=1:length(BegChasing)
       
       
     if  (EndChasing(i)-BegChasing(i))<10 %for small events less than 10 no consider
       
        ChasingVector(BegChasing(i):EndChasing(i))=0; %ELIMINATE CHASING EVENTS IF THERE AS LESS THAN 3 EVENTS
     
      
     else

       
    DeltaX1=Dx1(BegChasing(i):EndChasing(i));
    DeltaY1=Dy1(BegChasing(i):EndChasing(i));
    
    DeltaX2=Dx2(BegChasing(i):EndChasing(i));
    DeltaY2=Dy2(BegChasing(i):EndChasing(i));
    
   MedV1= median(V1(BegChasing(i):EndChasing(i)));
   MedV2= median(V2(BegChasing(i):EndChasing(i))); 
    
    DistFun1=sum(sqrt((DeltaX1).^2+(DeltaY1).^2));%all the distance done during this chasing   
    DistFun2=sum(sqrt((DeltaX2).^2+(DeltaY2).^2));   
     
    if DistFun1< MinimumPath | DistFun2< MinimumPath
        
      ChasingVector(BegChasing(i):EndChasing(i))=0; %ELIMINATE CHASING EVENTS IF THE TRAYECTORY ARE VERY SMALL  
    elseif   MedV1 < VelocityThresh | MedV2< VelocityThresh                   %check velocity median bigger than the thrheshold during this period if not it was not moving   
         ChasingVector(BegChasing(i):EndChasing(i))=0; %ELIMINATE CHASING EVENTS IF THE mouse is not moving enough for cases it is in the eating place all the time.
    end

   end
   
   
    
end

end

end

##### SOURCE END #####
--></body></html>